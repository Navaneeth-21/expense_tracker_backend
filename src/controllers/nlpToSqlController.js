// src/controllers/nlpToSqlController.js
const axios = require("axios");
const pool = require("../config/db");
const schemaInfo = require("../config/schemaInfo");
require("dotenv").config();

const GEMINI_API_URL =
  "https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent";
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

exports.processNlpToSqlRequest = async (req, res) => {
  try {
    const { prompt } = req.body;
    if (!req.user || !req.user.user_id) {
      return res.status(401).json({ error: "Unauthorized: User not authenticated" });
    }
    const userId = req.user.user_id;

    if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
      return res.status(400).json({ error: "Prompt is required and must be a non-empty string." });
    }

    const trimmedPrompt = prompt.trim();
    const sqlKeywords = [
      "select", "insert", "update", "delete", "show", "add", "calculate", "list", "find", "count", "sum", "average", "min", "max", "order", "group", "join", "filter", "sort", "search", "fetch", "identify", "locate",
      "paid", "spend", "expense", "revenue", "income", "earnings", "salary", "profit", "deposit", "withdraw", "track", "analyze", "categorize", "transactions", "payment", "cost", "bill", "purchase"
    ];
    if (!sqlKeywords.some(keyword => trimmedPrompt.toLowerCase().includes(keyword))) {
      return res.status(400).json({ error: "The given prompt is not related. Try a standard prompt" });
    }

    const formattedPrompt = `${schemaInfo}**"${trimmedPrompt}"**`;
    const requestBody = {
      contents: [{ role: "user", parts: [{ text: formattedPrompt }] }],
    };

    const response = await axios.post(
      `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
      requestBody,
      { headers: { "Content-Type": "application/json" }, timeout: 10000 }
    );

    const sqlQueryRaw = response.data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
    if (!sqlQueryRaw) {
      return res.status(400).json({ error: "No valid SQL query generated by AI." });
    }

    const sqlStatements = sqlQueryRaw
      .replace(/```sql|```/g, "")
      .split(';')
      .map(stmt => stmt.trim())
      .filter(stmt => stmt.length > 0);

    if (sqlStatements.length === 0) {
      return res.status(400).json({ error: "No valid SQL statements generated." });
    }

    // console.log("Generated SQL Statements:", sqlStatements); // debugging line

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Parse prompt directly as a fallback
      const lowerPrompt = trimmedPrompt.toLowerCase();
      const categoryMap = {
        'Revenue': ['income', 'sales', 'revenue'],
        'Rent': ['rent', 'lease', 'mortgage', 'property tax', 'insurance'],
        'Salaries': ['employee salaries', 'wages', 'bonuses', 'commissions', 'benefits'],
        'Staff Salaries': ['staff salaries', 'worker salaries', 'labor salaries'],
        'Utilities': ['groceries', 'electricity', 'water', 'gas', 'internet', 'phone', 'cleaning', 'repairs', 'maintenance'],
        'Food & Beverages': ['restaurants', 'cafes', 'bars', 'groceries', 'snacks', 'drinks'],
        'Transportation': ['fuel', 'gas', 'taxi', 'public transport', 'parking', 'tolls', 'vehicle maintenance'],
        'Health & Fitness': ['gym', 'fitness', 'health', 'medical', 'insurance', 'pharmacy'],
        'Technology & Gadgets': ['electronics', 'software', 'computers', 'mobile phones', 'gadgets'],
        'Business Expenses': ['office supplies', 'marketing', 'consulting']
      };
      let categoryName = null;
      for (const [category, keywords] of Object.entries(categoryMap)) {
        if (keywords.some(keyword => lowerPrompt.includes(keyword))) {
          categoryName = category;
          break;
        }
      }
      if (!categoryName) categoryName = 'Unknown';
      // console.log(`Prompt-parsed categoryName: ${categoryName}`); // debugging line

      const amountMatch = lowerPrompt.match(/\$?(\d+(?:\.\d+)?)/);
      let amount = amountMatch ? parseFloat(amountMatch[1]) : 0;
      if (categoryName !== 'Revenue') amount = -amount;
      // console.log(`Prompt-parsed amount: ${amount}`); // debugging line

      const methodMap = {
        'Cash': ['cash'],
        'Credit Card': ['credit card', 'credit'],
        'Debit Card': ['debit card', 'debit'],
        'Bank Transfer': ['bank', 'transfer']
      };
      let method = 'Cash';
      for (const [m, keywords] of Object.entries(methodMap)) {
        if (keywords.some(keyword => lowerPrompt.includes(keyword))) {
          method = m;
          break;
        }
      }
      // console.log(`Prompt-parsed method: ${method}`); // debugging line

      // Try parsing SQL first
      if (sqlStatements[0].toUpperCase().includes("INSERT INTO EXPENSES")) {
        const categoryMatch = sqlStatements[0].match(/VALUES\s*\('([^']+)'\s*ON\s*CONFLICT/i) || 
                            sqlStatements[0].match(/WHERE\s+name\s*=\s*'([^']+)'/i);
        if (categoryMatch) categoryName = categoryMatch[1];
        // console.log(`SQL-parsed categoryName: ${categoryName}`); // debugging line

        const sqlAmountMatch = sqlStatements[0].match(/amount,\s*([-]?\d+(?:\.\d+)?)/i);
        if (sqlAmountMatch) amount = parseFloat(sqlAmountMatch[1]);
        // console.log(`SQL-parsed amount: ${amount}`); // debugging line

        const sqlMethodMatch = sqlStatements.find(s => s.includes("INSERT INTO payments"))?.match(/'([^']+)'/i);
        if (sqlMethodMatch) method = sqlMethodMatch[1];
        // console.log(`SQL-parsed method: ${method}`); // debugging line
      }

      // Ensure category exists
      const categoryQuery = `
        INSERT INTO categories (name)
        VALUES ($1)
        ON CONFLICT (name) DO NOTHING
        RETURNING category_id;
      `;
      const insertResult = await client.query(categoryQuery, [categoryName]);
      const categoryId = insertResult.rows[0]?.category_id || 
                        (await client.query('SELECT category_id FROM categories WHERE name = $1', [categoryName])).rows[0]?.category_id;

      if (!categoryId) {
        throw new Error(`Failed to ensure category '${categoryName}' exists`);
      }
      // console.log(`Category '${categoryName}' ensured with category_id: ${categoryId}`); // debugging line

      // Insert expense and payment
      let expenseId;
      const expenseQuery = `
        INSERT INTO expenses (user_id, category_id, amount, description, expense_date, created_at)
        VALUES ($1, $2, $3, $4, CURRENT_DATE, CURRENT_TIMESTAMP)
        RETURNING expense_id;
      `;
      const expenseResult = await client.query(expenseQuery, [userId, categoryId, amount, trimmedPrompt]);
      expenseId = expenseResult.rows[0].expense_id;
      // console.log(`Inserted expense with expense_id: ${expenseId}, amount: ${amount}`); // debugging line

      const paymentQuery = `
        INSERT INTO payments (expense_id, method)
        VALUES ($1, $2);
      `;
      await client.query(paymentQuery, [expenseId, method]);
      // console.log(`Inserted payment for expense_id: ${expenseId}, method: ${method}`); debugging

      await client.query('COMMIT');
      res.json({ success: true, data: { expense_id: expenseId } });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error("Error executing SQL statements:", error);
      res.status(500).json({ error: "Failed to process request", details: error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error processing NLP to SQL:", error);
    res.status(500).json({ error: "Failed to process request", details: error.message });
  }
};

// module.exports = { processNlpToSqlRequest };